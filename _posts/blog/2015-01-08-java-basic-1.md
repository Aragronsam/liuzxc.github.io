---
layout: post
title: Java 基础
excerpt:
categories: blog
comments: true
share: true
---

#####变量

变量有两种：

1. primitive主数据类型（boolean, char, integer, byte, short, int, long, float, double)
2. 引用

变量命名规则： 必须以字母，下划线`_`或`$`符号开头；

实例变量有默认值，局部变量没有默认值；

变量的比较：

* `==`用于比较两个primitive主数据类型货判断两个引用是否引用同一个对象；
* `equals()`来判断两个对象是否在意义上相等（例如两个String对象是否带有相同的字节组合）;

#####循环

{% highlight java %}
int[] arr = {1,2,3,4,5};

for(int i=0;i<arr.length;i++) {...}

for(int i : arr) {...}

while(i < arr.length) {...}

{% endhighlight %}

#####Java API

要使用API中的类，你必须要知道它被放在哪个包中，有两种方式指定 Java 使用的类：

1. import 把 import 放在源文件的最前面；

{% highlight java %}
import java.util.ArrayList;
{% endhighlight %}

2. 在程序中打出全名；

{% highlight java %}
java.util.ArrayList<String> myList = new java.util.ArrayList<String>();
{% endhighlight %}

ArrayList: ArrayList 不同于普通数组，创建时不需要指定大小，并且可以调用其提供的大量方法；

{% highlight java %}
import java.util.ArrayList;
class Array {
  public static void main(String[] args){
	  ArrayList<String> myList = new ArrayList<String>();
	  String a = new String("liu");
	  myList.add(a);
	  String b = "xing";
	  myList.add(b);
	  System.out.println("the array list length is: " + myList.size());
	  String c = myList.get(1);
	  System.out.println(c);
	  boolean isIn = myList.contains(b);
	  int i = myList.indexOf(a);
	  boolean isEmpty = myList.isEmpty();
  }
}
{% endhighlight %}

#####继承

{% highlight java %}
public class <子类> extends <父类> {}
{% endhighlight %}

继承下来的方法可以被覆盖掉，但是实例变量不能被覆盖掉

######4种存取权限：

1. private: private类型的成员不会被继承；
2. default
3. protected
4. public: public类型的成员会被继承；

继承下来的方法可以被覆盖掉但实例变量不能被覆盖掉

######方法的覆盖：

1. 参数必须一样，且返回类型必须兼容；
2. 不能降低方法的存取权限；

######方法的重载：

重载的意义是方法的名称相同，但参数不同，重载与多态毫无关系。

1. 返回类型可以不同，但不可以只改变返回类型；
2. 可以更改存取权限；

{% highlight java %}
public class Animal {
 public void beFriendly() {
   System.out.println("father befriendly");
 }
 public int age() {
   return 5;
 }
}

public class Cat extends Animal {
  int weight = 15;
  public void beFriendly() {
    super.beFriendly(); //可以用super调用父类的方法
    System.out.println("son befriendly");
  }

  public int age() {
    return 6;
  }

  public static void main(String[] args) {
    Cat c = new Cat();
    c.beFriendly();
    System.out.println(c.age());
    System.out.println(c.weight);
  }
}

#####多态

抽象类：抽象类代表没有人能创建出该类的实例，抽象类除了被继承过之外，没有用途，没有值，没有目的。

{% highlight java %}
abstract class Animal {}
{% endhighlight %}

抽象方法：抽象方法代表此方法一定被覆盖过。

* 抽象方法没有实体

{% highlight java %}
public abstract void eat();
{% endhighlight %}

* 如果声明一个抽象的方法，必须将类也标记为抽象的，不能在非抽象类中拥有抽象方法，但抽象类中可以有非抽象方法。

#####接口

接口`interface`可以用来解决多重继承问题,接口的方法一定是抽象的。

接口的定义：

{% highlight java %}
public interface Pet {....}
{% endhighlight %}

接口的实现：

{% highlight java %}
public class Dog extends Canine implements Pet {....}
//类可以实现多个接口
public class Dog extends Canine implements Pet, Saveable, Paintable {....}
{% endhighlight %}

Pet.java:

{% highlight java %}
public interface Pet {
  //接口的方法必须是抽象的，所以它们没有内容，必须以分号结尾
  abstract void beFriendly();
  abstract void play();
}
{% endhighlight %}

Dog.java:

{% highlight java %}
public class Dog implements Pet {
 //Dog类必须实现Pet的方法
 public void beFriendly() {
   System.out.println("befriendly");
 }
 public void play() {
   System.out.println("play");
 }

 public static void main(String[] args){
   Dog d = new Dog();
   d.beFriendly();
   d.play();
 }
}
{% endhighlight %}

#####构造器

######构造函数

构造函数带有你在初始化对象时会执行的程序代码，也就是新建一个对象时会被执行，如果你没有写构造函数，编译器会帮你写。
但是需要注意，编译器只会在你完全没有设定构造函数时才会帮你写构造函数。如果你已经写了一个有参数的构造函数，并且你还
需要一个没有参数的构造函数，你必须自己手动写。

{% highlight java %}
public class Duck{
  //构造函数没有返回类型，而且要与类的名称相同
  public Duck(){
    System.out.println("duck initlalize");
  }

  public Duck(int i){
    System.out.println("initlalize:" + i);
  }

  public static void main(String[] args){
    Duck d = new Duck();
  }
}
{% endhighlight %}

> 在Ruby中构造函数名为intialize，但是ruby和java不同的是，ruby并不支持函数重载，它通过设置默认参数来实现带有
不同个数参数的构造函数

{% highlight ruby %}
class Duck
   def initialize(name = nil)
     puts "init object"
   end
end

d = Duck.new
{% endhighlight %}

在创建新对象时，所有继承下来的构造函数都会执行，先执行父类的，再执行子类的

{% highlight java %}
public class Duck1 extends Duck{
    public Duck1(){
       System.out.println("duck1 initialize");
    }
    public static void main(String[] args){
      Duck1 d = new Duck1();
   }
}
➜

=> duck initlalize
   duck1 initlalize
{% endhighlight %}

> ruby在创建新的对象时，并不会自动执行来自父类的构造函数

{% highlight ruby %}
class Duck
   def initialize
     puts "duck init"
   end
end

class Duck1 < Duck

  def initialize
     #可以使用super调用父类的构造函数
     #super
     puts "duck1 init"
  end

end


d1 = Duck1.new => "duck1 init"
{% endhighlight %}

super() VS this()

1. super()用于调用父类的构造函数
2. this()用于从某个构造函数调用同一个类的另外一个构造函数，this()只能用在构造函数中，且必须是第一行语句
3. 每个构造函数可以选择调用super()或this()，但不能同时调用

{% highlight java %}
public class Duck1 extends Duck{
    public Duck1(){
       System.out.println("duck1 initialize");
    }
    public Duck1(int i){
       this(); //调用上面的构造函数Duck1()
       System.out.println("duck1 initialize" + i);
    }
    public static void main(String[] args){
      Duck1 d = new Duck1(100);
   }
}

=> duck initlalize
   duck1 initialize
   duck1 initialize100
{% endhighlight %}

#####静态

######静态方法

用static关键字标记方法是静态方法

1. 静态的方法不能调用非静态的变量
2. 静态方法也不能调用非静态的方法(可以在静态方法中创建类的实例，通过该实例调用非静态方法)

{% highlight ruby %}
class Test{
   public static void test(){
     System.out.println("static method");
   }

   public static void main(String[] args){
      Test.test();
   }
}
{% endhighlight %}

> java中的静态方法类似于ruby的类方法

{% highlight ruby %}
class Test
    def self.test
       puts "class method"
    end
end

Test.test
{% endhighlight %}

######静态变量

1. 静态变量被同类的所有实例所共享
2. 静态变量会在该类的任何静态方法执行之前就初始化

{% highlight java %}
public class Test{
   public static int count = 0;
   public Test(){
    count++;
    System.out.println("count: "+ count);
   }

   public static void main(String[] args){
     Test t = new Test();
     Test t1 = new Test();
   }
}

count: 1
count: 2
{% endhighlight %}

> java的静态变量类似于ruby的类变量

{% highlight ruby %}
class Test
    @@count = 0
    def initialize
      @@count += 1
      puts "@@count: #{@@count}"
    end
end

t = Test.new
t1 = Test.new

@@count: 1
@@count: 2
{% endhighlight %}

######静态final变量

一个被标记为final的变量到表它一旦被初始化之后就不会改动，也就是说类加载之后静态fianl变量就一直会维持原值

1. 常量的名称应该是大写字母
2. java中的常量是把变量同时标记为static和final的

{% highlight java %}
public class Test{
   //常量的名称应该是大写字母
   public static final int SIZE = 100;

   public static void main(String[] args){
     System.out.println(Test.SIZE);
   }
}
{% endhighlight %}

#######final的其他用途

1. final的method不能被覆盖；
2. final的类不能被继承；


#####异常处理

异常是一种Exception类型的对象
编译器不会注意RuntimeException类型的异常
方法可以用throw关键字抛出异常对象

{% highlight java %}
try {
	//危险动作
} catch(Exception ex) {
	//尝试恢复
} finally {
    //不管有没有异常都得执行的程序
}
{% endhighlight %}

{% highlight java %}
public class Test{
   public void divide() throws Exception {
     for(int i=10;i>=0;i--){
        System.out.println(100/i);
     }
   }
   public static void main(String[] args){
     Test t = new Test();
     try{
       t.divide();
       System.out.println("test1"); //如果divide()不出异常，该句不会被执行
     } catch(Exception ex) {
       System.out.println("exception found");
     } finally {
       System.out.println("finally");
     }
   }
}
{% endhighlight %}

> java的异常处理机制与ruby的非常相似

{% highlight ruby %}
begin
  ...
rescue(exception ex)
  ...
ensure
  ...
end
{% endhighlight %}

######处理多种异常

{% highlight java %}
public void play() throws Exception1, Exception2 {....}

try {
    ...play()
} catch(Exception1 ex1) {
	...
} catch(Exception2 ex2) {
	...
}
{% endhighlight %}

#####内部类

{% highlight ruby %}
calss OuterClass {

	class InnerClass {
		void go() {...}
	}
}
{% endhighlight %}

1. 内部类可以使用外部类的所有方法和变量
2. 内部类的实例一定会绑在外部类的实例上

